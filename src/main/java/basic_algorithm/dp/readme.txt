dynamic plann 动态规划（LeetCode常考）——号称算法接近最难的地方

动态规划就是把大问题变成小问题，并解决了小问题重复计算的方法称为动态规划

动态规划和 DFS 区别
1. 二叉树 子问题是没有交集，所以大部分二叉树都用递归或者分治法，即 DFS，就可以解决
2. 像 triangle 这种是有重复走的情况，子问题是有交集，所以可以用动态规划来解决


动态规划三个特性：(选自https://github.com/wardseptember/notes/blob/master/docs/LeetCode/basic_algorithm/dp.md)
    1. 最优子结构
    最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。
    2. 无后效性
    无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。
    3. 重复子问题
    如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。所以才会用一个数组记录中间结果，避免重复计算。

    总结：动态规划，自底向上 这里变成一位数组（最开始可以用2位数组），因为层号实际上可以不用记录，每次记录上一层的值，到当前层就把以前的覆盖到，动态规划运用场景其中一条就是最优子结构，往下走不用回头一定是最优的

    本质上就是找公式的规律

使用场景：
满足两个条件
    满足以下条件之一
        求最大/最小值（Maximum/Minimum ）
        求是否可行（Yes/No ）
        求可行个数（Count(*) ）
    满足不能排序或者交换（Can not sort / swap ）

四点要素
    状态 State
        灵感，创造力，存储小规模问题的结果
    方程 Function
        状态之间的联系，怎么通过小的状态，来算大的状态
    初始化 Intialization
        最极限的小状态是什么, 起点
    答案 Answer
        最大的那个状态是什么，终点

常见四种类型
    Matrix DP (10%)
    Sequence (40%)
    Two Sequences DP (40%)
    Backpack (10%)

Solution120： 真.经典动态规划题。找到最后一行的f[][]，再比较大小。（其实也可以使用dfs，但直接不符合题意）

1、矩阵类型（10%）
Solution64: 核心公式在于 f[i][j] = Math.min(f[i-1][j],f[i][j-1])+grid[i][j];
Solution62: 核心在于pathCount[i-1][j]和pathCount[i][j-1]所经过的路径一定是不同的
Solution63: 在62的基础上很容易，多一个障碍物的判断，是障碍物则取0

2、序列类型（40%）——先想动态规划，再想贪心算法
Solution70：核心在于公式dp[i] = dp[i-1] + dp[i-2]
Solution55:先使用动态规划进行一步一步推导，再根据其基础推导出贪心算法
Solution45:先使用动态规划进行一步步推导，公式Math.min(dp[i]+1,dp[i+j]),再根据其特性推导出简易版的贪心算法
Solution5: 画格子,然后找到递归公式d[i][j]=d[i+1][j_1]&&s[i]==s[j]
Solution300: 核心在于找到公式dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]
Solution139: 方法一：dp[i]=dp[j] && check(s[j..i−1])。方法二，顺序背包问题，物品迭代在外面，背包迭代在里面

3. Two Sequences DP（40%）——此类问题一般为字符串问题，从空字符开始考虑会很有帮助
Solution1143:遍历两个字符串:1、若 当前两个字符:相等当前状态=两个元素的前一个状态+1 2、若 当前两个字符不等：当前状态=两个元素任一元素的前一个状态的最大值
Solution72： 建议从递归方式思考，再推出公式dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1

4、零钱和背包（10%）
Solution322: 背包问题，类似139.核心在于公式F(i)=MIN(F(i-j)+1,F(i))
Solution92_Lin: 0/1背包问题，物品有且只有一件。https://mp.weixin.qq.com/s/RXfnhSpVBmVneQjDSUSAVQ
Solution125_Lin: 同上




